---
title: 面试面经优化回答
categories:
  - 面经
abbrlink: 2708
date: 2025.8.14
tags: 
   - 面试
---

# Spring框架

## 1.SpringBoot的配置加载优先级

首先我们先确定一下配置加载优先级是按照我以下的顺序，由高到低的。分别是：

1. 先是**命令行参数**（`--server.port=9000` 或 `java -jar app.jar --spring.config.location=...`）

2. 然后是我们的系统的环境变量和JVM系统属性，比如设置端口为8080，比如我们在这里设置API的KEY

3. 然后**`RandomValuePropertySource`**（`random.*` 占位符，用于生成随机数/字符串，可在配置中引用）

4. 接着是**外部配置文件**（properties / yml）

   - JAR 包外部的 `./config/`

   - JAR 包外部的 `./`

   - JAR 包内部的 `classpath:/config/`

   - JAR 包内部的 `classpath:/`

5. 接着是我们@PropertySource注解指定的配置

6. 最后是我们Springboot默认的配置

然后在配置文件中，properties的配置大于yml，因为springboot是按加载顺序来的，后加载的properties把yml的值给覆盖了

对于外部配置文件，查找路径的优先级为：

1. `./config/`（当前目录下的config目录）
2. `./`（当前目录）
3. `classpath:/config/`
4. `classpath:/`

实际应用:

**基础配置**：放在 `classpath:/application.yml`

**环境特定配置**：使用 `application-{profile}.yml`（如 `application-prod.yml`），通过 `--spring.profiles.active=prod` 激活

**敏感信息**：放在环境变量或外部化配置文件（避免入库）

**临时调试/测试**：使用命令行参数临时覆盖

**多环境冲突处理**：利用 profile 合并特性，公共配置放在 `application.yml`，环境差异放在对应 profile 文件

## 3.谈谈怎么理解线程安全的

**线程安全**指的是当多个线程同时访问一个对象或方法时，无论操作系统如何调度这些线程，也无需调用方在代码中去做额外的同步处理，都能保证程序的正确性，不会出现数据损坏或不一致的情况。

线程不安全的问题通常会表现在三个方面

1. 原子性：一个或多个操作作为一个不可分割的整体来进行，要去这个操作序列，必须由一个线程独占完整的去执行，不能被其他线程所干扰，调不可被中断。i++
2. 可见性：一个线程修改了一个共享变量的值，这个修改的值能够被其他线程看到。但是实际在CPU的高速缓存下，对指令做出的重排序操作，导致共享变量的值，对其他线程不是立即课件的。缓存读的旧值
3. 有序性：写的代码的顺序和实际代码的顺序不一致，是由于编译器和处理器层面对指令重排优化导致的，可能会导致可见性问题

我们可以使用voliate或者是直接加synchronized，或者是直接加锁

或者使用原子类的CAS，或者是线程安全的ThreadLocal

## 2.Springboot是如何解决跨域问题的？

基本都是基于CORS（跨域资源共享）通过设置响应头（如 `Access-Control-Allow-Origin`、`Access-Control-Allow-Methods`、`Access-Control-Allow-Headers`）告诉浏览器允许访问。

对于复杂跨域请求（非 GET/POST/HEAD 或自定义头），浏览器会先发 **OPTIONS 预检请求**。

1. 局部注解，用@CrossOrigin标记单个接口，秒开跨域权限，适合快速测试。简单高效，优先级高于全局配置
2. 全局配置，使用WebMvcConfigurer接口，统一设定允许的域名，请求方法，头信息。统一配置，但是不适合动态的控制
3. 用CorsFilter手动处理跨域逻辑处理，适合需要动态校验权限等特殊场景，比如不同权限开放不同接口，在过滤器中动态判断，但是实现成本较高
4. 在微服务架构中，也可以在**网关层**（如 Spring Cloud Gateway、Nginx）统一处理跨域，减少业务服务配置。

优先级：

```
@CrossOrigin` > `WebMvcConfigurer` > `CorsFilter
```



# JUC

## 1.线程池常见的坑

1. 线程池的参数配置：核心线程的数量，和最大线程的数量是业务场景来的，CPU密集型，比如数据的计算业务，就是CPU的数量+1。

   IO密集型根据业务压测的值来决定的，最佳线程数=（（线程等待时间+线程CPU时间）/线程CPU时间）*CPU数量

比如，我们服务器CPU核数为8核，任务线程CPU耗时20ms,线程等待等等耗时80ms，那么最佳线程数=（80+20）/20*8=40线程，那我们最大线程数就是80个

2. 共享线程池，次要的逻辑拖垮主要的逻辑。避免所有的业务都共享一个线程池，防止一个次要的业务一直在执行业务，占用线程池。而主要的业务并没有足够的线程数来执行，影响到了我们主要的服务。这样做是不合理的。我们应该要做线程池的隔离，使用Future.get方法的时候，使用带超时时间的，因为他是阻塞的，防止被其他抢占。
3. @Async是Spring中一个注解，他不是线程池，他其实是SimpleAsyncTaskExecutor，不会复用线程，适合执行大量短时间的线程。还是尽量自己定义一个异步的线程池，然后使用@EnableAsync来注册
4. 使用线程池的时候，不使用threadfactory参数来自定义命名，这样导致后期不好排查问题和回溯问题
5. 使用submit提交任务，不会把异常直接抛出来。最好我们在submit之中进行try-catch进行捕获，或者是在 `Future.get()` 时捕获并记录异常。
6. 线程池使用完之后，记得关闭，防止内存泄漏的问题。最好线程池设计成单例的模式。长期运行的全局线程池（如 Spring 管理的）不需手动关闭，临时线程池需在 finally 中调用 `shutdown()`。
7. 线程池不要和事务一起使用，使用@Transtation的时候，依赖于当前线程的线程上下文，而线程池的线程和当前事务的线程不是一个线程，事务的上下文不会传递，导致线程池中的业务代码不在事务中执行，事务就失效了。我们可以将事务放在线程池之外进行，这是最好的方法，或者是使用支持事务上下文传递的机制（如 `TransactionAwareDataSourceProxy`、消息队列保证一致性）

8. 我们要负责监控线程池状态，比如当前活跃的线程池的数量，队列的长度，拒绝的次数
9. 要配置合理的拒绝策略，比如一个需要快速获取结果的线程，就需要胚子和callerrunpolicy，这样的话，谁提交谁执行，回退给调用的线程。

## 2.AQS的大局解析



AQS是JUC里面的一个抽象同步框架，核心的作用就是统一分装了线程的等待唤醒排队机制。

底层通过一个volatile的state变量+FIFO的队列来实现线程安全的资源性抢夺

state表示资源的状态，独占锁里面0没人占，1就是已经上锁。可重入锁里面数字代表可重入的次数

线程要抢不到锁，就会被挂到队列里面进行排队，队列是双向链表实现的CLH队列，节点记录了等待状态，信息等

他只是一个框架，真正的锁逻辑交给实现类自己决定



# JVM

# JavaSE

# Mysql

## 1.多表join的时候，小表驱动大表

在Mysql的 Nested Loop Join 中

**驱动表（outer table）**：首先被扫描的表。

**被驱动表（inner table）**：对驱动表每一行，根据 Join 条件去查找匹配行的表。

**核心原则**：过滤后剩余行数少的表，应该作为驱动表，这样可以减少被驱动表的访问次数。这就是小表



执行过程：

扫描驱动表（全表扫描或索引扫描）。

对驱动表的每一行，根据连接条件在被驱动表中查找（通常用索引 B+Tree 查找）。

如果被驱动表使用二级索引且需要回表，则访问主键索引。

小表驱动大表，大表负责命中索引。

比如

```
select * from A straight_join B on A.a = B.a;
```

数据库会全表扫A，然后每拿到一行就去比较条件 A.a=B.a，去B表里面查，B表命中索引的查询。实际上就是一个搜索树，查询的时间复杂度近似log2^B^，然后加上一次回表，可能就是2Log2 ^B^,所以总体的时间复杂度为A+2log2^B^*A，如果是覆盖索引的话，复杂度可降为 O(A + log₂(B) × A)

所以我的们A越小越好，join的本质就是查驱动表，然后扫被驱动表，当然是查的越少越好了



# Redis

# MQ





