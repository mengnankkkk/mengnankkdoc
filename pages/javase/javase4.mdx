# javase源码详解

## 1.==和equal()和hashcode

==和equals函数对于基本类型来说， = = 比较是值，equals不能比较基本类型

对于包装类型来说，== 比较的是对象的引用，就是对象的内存地址。而`equals()`通常被重写以比较对象的值。

需要注意的是，像Interger这种包装类具有缓存机制，如果在缓存的范围，==的结果可能就是true，因为他们都是指向常量池的同一个对象

对于引用类型来说，==比较的是其对象的内存地址，equals要分为两个情况，看这个类型到底重写了equals函数了没，重写了就按重写的比较，比如String类型，他的equals就是比较的对象的值。然后没有重写的话，equals内部还是使用 ==来比较。没有什么区别。还是比较的对象的内存地址



hashcode函数的作用是获取哈希码，然后确定该对象再hash表中的位置，比如hashmap,hashset,布隆过滤器等都用到了hashcode

hasecode分为好几种哈希函数，有取模的，有进行位运算的。我们在布隆过滤器中使用最好是使用两种hash函数来确定位的位置。

`hashCode()` 定义在 JDK 的 `Object` 类中，这就意味着 Java 中的任何类都包含有 `hashCode()` 函数。另外需要注意的是：`Object` 的 `hashCode()` 方法是本地方法，也就是用 C 语言或 C++ 实现的

然后hashcode相同，equals不一定相同。hashcode不相同，这个对象一定不相同。这样的话，我们可以将hashcode和equals函数相结合。我们先用hash函数来判断，然后再用equals判断

如果这个对象真的不相同的话，那我们就可以用运行速度快的hash函数早判断。然后出现hash碰撞的时候我们再用equals函数来确定是不是真的相同。这样大大提高了效率，因为hash函数的运算是比equals快的。这也是hashmap,hashset，布隆过滤器的设计原理。

因此，我们在重写equals的时候，hashcode也必须重写，否则就会出现equals相等，但是hash不相同。就会出现重复值的问题

## 2.BigDecimial处理精度丢失的问题

`BigDecimal`是Java中用于处理高精度数值计算的类，尤其适用于金融、科学计算等对精度要求极高的场景。

最关键的就是两个字段：

- `intVal`: 一个`BigInteger`对象，用于存储数值的**非标度值 (unscaled value)**。简单来说，就是去掉小数点后的整数值。
- `scale`: 一个`int`类型的整数，表示**标度 (scale)**。标度指的是小数点后的位数。例如，对于数值 123.45，`intVal`是12345，`scale`是2。

`BigDecimal` **使用整数来表示数值，避免了浮点数的二进制表示法引入的精度问题。** 它通过`scale`来记录小数点的位置，从而实现对小数的精确表示。

BigDecimal的运算都是基于BigInterger来实现的

- 加减法的时候，调整两个数的sacle，对齐标度，然后将intval相加减，最好创建一个新的BigDecial对象，intval为相加减的结果，scale为调整后的标度

- 乘法，将两个数的intval想乘，然后scale为两个BigDecimal的scale的和

- 除法是最复杂的操作，因为可能产生无限循环小数，`BigDecimal`需要提供多种舍入模式 (RoundingMode) 来控制精度，比如

  - `ROUND_UP`: 向上舍入

  - `ROUND_DOWN`: 向下舍入

  - `ROUND_CEILING`: 向正无穷方向舍入

  - `ROUND_FLOOR`: 向负无穷方向舍入

  - `ROUND_HALF_UP`: 四舍五入 (大于等于0.5向上舍入)

  - `ROUND_HALF_DOWN`: 五舍六入 (大于0.5向上舍入)

  - `ROUND_HALF_EVEN`: 银行家舍入 (四舍六入，五看奇偶，偶舍奇入)`BigDecimal`会根据指定的舍入模式，计算出精确的结果，并截断到指定的精度。

    

但是会出现很多个BigDecimal对象：Bigdecimal 是一个immutable类，每次计算都会new一个新的对象。如果在一个循环内多次使用bigdecimal，会生成很多对象，影响性能，建议如果在循化内不要使用string 构造出bigdecimal, 否则生成大量的string对象和bigdecimal对象

## 3.变量

成员变量&&局部变量对比--变量存储的内存地址对应的任意随机值

- 定义：成员变量是属于类的，局部变量是在代码块或者方法之中的
- 存储：成员变量如果是使用static的话，那这个成员变量属于类，没有的话，在堆。局部变量在栈，栈之中维护了一个局部变量表
- 生存时间：成员变量是对象的一部分，跟对象的生命周期一样，局部变量跟他的方法的生命周期一样
- 默认值：成员变量没有被赋值的话，一般都会是类型的默认值，除非是final修饰的，必须显示的赋值，局部变量不赋值会报错。

| 特性          | 成员变量 (Instance Variable)                                 | 成员变量 (Static Variable)                                   | 局部变量 (Local Variable)                                    |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **定义**      | 属于类的属性，在类中方法外定义。                             | 属于类的静态属性，在类中方法外定义，用`static`修饰。         | 在方法、代码块（如`if`、`for`语句内部）中定义的变量。        |
| **存储**      | 存储在堆内存（Heap）中，作为对象的一部分。                   | 存储在方法区（Method Area）或元空间(Metaspace)中。（JDK8+之后静态变量从方法区移动到了堆中，但逻辑概念上仍与类相关联） | 存储在Java虚拟机栈（Java Virtual Machine Stack）的栈帧（Stack Frame）的局部变量表中。 |
| **生命周期**  | 随着对象的创建而创建，随着对象的销毁而销毁。                 | 随着类的加载而创建，随着类的卸载而销毁。（实际上与类的 Class 对象关联） | 随着方法的调用而创建，随着方法的执行结束而销毁。             |
| **默认值**    | 存在默认值。如果没有显式赋值，会赋予类型的默认值（如`int`为0，`boolean`为`false`，`Object`为`null`）。 | static 变量在类加载的准备阶段就会赋默认值. 如果没有显式赋值，会赋予类型的默认值（如`int`为0，`boolean`为`false`，`Object`为`null`）。 | 不存在默认值。**必须显式赋值**后才能使用，否则编译报错。     |
| **final修饰** | `final`修饰的成员变量必须在对象创建前（构造器或声明时）显式赋值，之后不能修改。 | `final static`修饰的成员变量必须在类加载完成前（静态代码块或声明时）显式赋值，之后不能修改。 | `final`修饰的局部变量必须在使用前显式赋值，之后不能修改。    |
| **线程安全**  | 线程不安全，每个对象都有一份独立的成员变量副本，如果多个线程修改同一个对象的成员变量，可能导致数据不一致。 | 线程安全，所有该类的对象共享同一个静态变量，需要进行同步处理才能保证线程安全。 | 线程安全，局部变量只在当前线程的栈帧中有效，不同线程之间互不影响。 |



## 4.String家族三位

